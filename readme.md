# このリポジトリの意図
　最近 arm64 のアセンブラに関心を持つようになった。今の時代、アセンブラを用いるのは組み込み系に利用するためか、simd 命令を利用するためかのどちらかであろうと思う。  
　simd 命令は実際に書いてみないと分かりにくいので、sha1 と base64 を simd 命令を用いて書いてみることにした。  
　arm64 の simd 命令（neon）を知りたい人にとって、難しすぎず簡単すぎずといったちょうど良いサンプルとなると思う。

（補足）私は Websocket をよく利用するため、Websocket に利用しやすい形で実装している。

# リポジトリの内容
* sha1.s : sha1 ハッシュ値を出力する
* base64.s : base64 文字列を出力する

* main.s : sha1.s のテスト用
* DBG.s : デバッグ用
* test.sh : main.s をシェルから起動して確認するスクリプト

# sha1.s について
* v0 と v1.s[1] にハッシュ初期値を設定し、v20 から v23 に 512bit ブロックの値を設定してコールすると、v0 と v1.s[1] に sha1 ハッシュ値が返される。

```
ハッシュ初期値を A, B, C, D, E（A から E は 32bit値）とした場合、以下のように v0 と v1 に値を設定する。

v0.s[3] = D、v0.s[2] = C、v0.s[1] = B、v0.s[0] = A、v1.s[1] = E
レジスタ内には、ビッグエンディアンで値を格納すること。

main.s を参照するとわかるように、x1 に 512bit ブロックの先頭アドレスが入っていた場合、以下のようにすることを想定している。

		ld1		{v20.16b}, [x1], 16
		ld1		{v21.16b}, [x1], 16
		ld1		{v22.16b}, [x1], 16
		ld1		{v23.16b}, [x1], 16

		// ビッグエンディアンに並べ替える
		rev32	v20.16b, v20.16b
		rev32	v21.16b, v21.16b
		rev32	v22.16b, v22.16b
		rev32	v23.16b, v23.16b
    
レジスタ内の値の格納され方を調べるには、DBG.s 内のルーチンを利用すると良い。
```

# main.s について
* Websocket の応答用の例として作られている。Websocket のキーとなる 22文字（末尾の「==」は除く）を標準入力として与えると、応答用の値が 16進数文字列で返される。
* 実際に利用するには、test.sh を参照すると分かりやすいと思う。
